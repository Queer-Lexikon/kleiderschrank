import PronounTool from "../../domain/pronounTool.js";
import { createRandomFullName } from "../../domain/names.js";
import {
  FALLBACK_LAST_NAME_NOTICE,
  RESULTS_DEFAULT_HEADING,
} from "../../app/constants.js";
import { createDeclensionView } from "./declensionView.js";
import { createResultsHeader } from "./resultsHeader.js";
import { getSampleTextEntry, isDeclensionText } from "../texts.js";

// The tool only needs the pronoun sets passed into render().
const tool = new PronounTool([]);

/**
 * Render results into the container and return render metadata.
 * @param {object} params
 * @returns {{pronounSet: object|null, selectedName: object, listenButton: HTMLElement|null}}
 */
export function renderResults({
  resultsContainer,
  names,
  pronounSets,
  salutation,
  textKey,
  randomMode,
  ttsAvailable,
  ttsSpeaking,
  declensionTabId,
  onDeclensionTabChange,
}) {
  const selectedEntry = getSampleTextEntry(textKey);
  const text = selectedEntry?.text ?? "";
  const isDeclensionView = isDeclensionText(textKey);
  const safeNames =
    names && names.length > 0 ? names : [createRandomFullName(null)];
  // Track whether all names are auto-generated to inform marker labeling.
  const defaultNameSource =
    safeNames.length > 0 && safeNames.every((person) => person.isAutoGenerated)
      ? "auto"
      : "";
  // In single mode, pick a single name unless declension view requires all.
  const effectiveNames = isDeclensionView
    ? safeNames
    : randomMode === "single"
      ? [safeNames[Math.floor(Math.random() * safeNames.length)]]
      : safeNames;
  const peopleWithSalutation = effectiveNames.map((person) => ({
    firstName: person.firstName,
    lastName: person.lastName,
    lastNameSource: person.lastNameSource || "user",
    salutation,
    isAutoGenerated: Boolean(person.isAutoGenerated),
  }));
  resultsContainer.innerHTML = "";
  resultsContainer.dataset.nameSourceDefault = defaultNameSource;
  const { headingRow, heading, listenButton } = createResultsHeader({
    title:
      selectedEntry && selectedEntry.title
        ? selectedEntry.title
        : RESULTS_DEFAULT_HEADING,
    ttsAvailable,
    ttsSpeaking,
    includeListenButton: !isDeclensionView,
  });

  resultsContainer.appendChild(headingRow);

  if (isDeclensionView) {
    const view = createDeclensionView({
      pronounSets,
      names: effectiveNames,
      initialTabId: declensionTabId,
      onTabChange: onDeclensionTabChange,
    });
    resultsContainer.appendChild(view);
    return {
      pronounSet: null,
      selectedName: effectiveNames[0],
      listenButton: null,
    };
  }

  const paragraph = document.createElement("p");

  const result = tool.render(
    text,
    peopleWithSalutation,
    pronounSets,
    randomMode,
  );

  const pronounSuffix =
    randomMode === "single" && result.pronounSet
      ? ` â€“ ${result.pronounSet.bezeichnung}`
      : "";
  heading.textContent += pronounSuffix;

  paragraph.innerHTML = result.html;
  resultsContainer.appendChild(paragraph);

  // Add a user-facing notice if a random last name has been used so people aren't terrified when they accidentally see their real last name without providing it.
  if (result.usedAutoLastName) {
    const disclaimer = document.createElement("p");
    disclaimer.className = "results-disclaimer";
    const icon = document.createElement("img");
    icon.src = "img/fas-info.svg";
    icon.alt = "";
    icon.setAttribute("aria-hidden", "true");
    icon.className = "results-disclaimer__icon";
    disclaimer.appendChild(icon);

    const textNode = document.createElement("div");
    textNode.className = "results-disclaimer__text";
    textNode.textContent = FALLBACK_LAST_NAME_NOTICE;
    disclaimer.appendChild(textNode);
    resultsContainer.appendChild(disclaimer);
  }

  return {
    pronounSet: result.pronounSet || null,
    selectedName: effectiveNames[0],
    listenButton,
  };
}
