/**
 * Tests for name parsing and normalization.
 */
import test from "node:test";
import assert from "node:assert/strict";
import {
  parseNames,
  createRandomFullName,
  getNameKey,
  normalizeNames,
} from "../src/domain/names.js";
import firstNames from "../data/firstNames.js";
import lastNames from "../data/lastNames.js";

/**
 * Build a fake input array that matches the parseNames signature.
 * @param {string[]} values
 * @returns {Array<{value: string}>}
 */
const makeInputs = (values) => values.map((value) => ({ value }));

test("Parses full and partial names", () => {
  const parsed = parseNames(makeInputs(["Alex Smith", "Sam"]));
  assert.equal(parsed.length, 2);
  assert.equal(parsed[0].firstName, "Alex");
  assert.equal(parsed[0].lastName, "Smith");
  assert.equal(parsed[1].firstName, "Sam");
  assert.equal(parsed[1].lastName, "");
  assert.equal(parsed[1].isAutoGenerated, false);
});

test("Returns no names for blank input", () => {
  const parsed = parseNames(makeInputs(["  ", ""]));
  assert.equal(parsed.length, 0);
});

test("Marks random names as auto-generated", () => {
  const preview = createRandomFullName(
    getNameKey({ firstName: "Alex", lastName: "Smith" }),
  );
  assert.equal(preview.isAutoGenerated, true);
  assert.equal(preview.lastNameSource, "auto");
});

test("Retries when the excluded key matches", () => {
  const originalRandom = Math.random;
  Math.random = () => 0;

  const excludeKey = getNameKey({
    firstName: firstNames[0],
    lastName: lastNames[0],
  });
  const preview = createRandomFullName(excludeKey);
  assert.equal(preview.isAutoGenerated, true);

  Math.random = originalRandom;
});

test("Stops retrying after max attempts", () => {
  const originalRandom = Math.random;
  const originalFirst = firstNames.slice();
  const originalLast = lastNames.slice();
  let calls = 0;

  firstNames.length = 0;
  lastNames.length = 0;
  firstNames.push("Alex");
  lastNames.push("Smith");

  Math.random = () => {
    calls += 1;
    return 0;
  };

  const excludeKey = getNameKey({ firstName: "Alex", lastName: "Smith" });
  const preview = createRandomFullName(excludeKey);
  assert.equal(getNameKey(preview), excludeKey);
  assert.equal(calls >= 40, true);

  Math.random = originalRandom;
  firstNames.length = 0;
  lastNames.length = 0;
  originalFirst.forEach((name) => firstNames.push(name));
  originalLast.forEach((name) => lastNames.push(name));
});

test("Falls back when name lists are empty", () => {
  const originalFirst = firstNames.slice();
  const originalLast = lastNames.slice();
  firstNames.length = 0;
  lastNames.length = 0;

  const preview = createRandomFullName();
  assert.equal(preview.firstName, "Alex");
  assert.equal(preview.lastName, "");

  originalFirst.forEach((name) => firstNames.push(name));
  originalLast.forEach((name) => lastNames.push(name));
});

test("Accepts empty exclude keys", () => {
  const preview = createRandomFullName();
  assert.equal(preview.isAutoGenerated, true);
});

test("Returns immediately when the excluded key does not match", () => {
  const originalRandom = Math.random;
  Math.random = () => 0;

  const preview = createRandomFullName("non-matching");
  assert.equal(preview.isAutoGenerated, true);

  Math.random = originalRandom;
});

test("Adds last names when missing", () => {
  const normalized = normalizeNames([{ firstName: "Sam", lastName: "" }], {
    defaultNameFactory: () => ({
      firstName: "Alex",
      lastName: "Smith",
      isAutoGenerated: true,
      lastNameSource: "auto",
    }),
  });
  assert.equal(normalized[0].firstName, "Sam");
  assert.equal(normalized[0].lastName.length > 0, true);
  assert.equal(normalized[0].lastNameSource, "auto");
});

test("Uses a default factory when no names are provided", () => {
  const normalized = normalizeNames([], {
    defaultNameFactory: () => ({
      firstName: "Alex",
      lastName: "Smith",
      isAutoGenerated: true,
      lastNameSource: "auto",
    }),
  });
  assert.equal(normalized.length, 1);
  assert.equal(normalized[0].firstName, "Alex");
  assert.equal(normalized[0].lastName, "Smith");
});

test("Uses built-in fallback when input is missing", () => {
  const normalized = normalizeNames();
  assert.equal(normalized.length, 1);
  assert.equal(normalized[0].isAutoGenerated, true);
});

test("Preserves user-provided last names", () => {
  const normalized = normalizeNames([
    { firstName: "Alex", lastName: "Stone", isAutoGenerated: false },
  ]);
  assert.equal(normalized[0].lastName, "Stone");
  assert.equal(normalized[0].lastNameSource, "user");
});

test("Handles missing first names", () => {
  const normalized = normalizeNames([
    { lastName: "Stone", isAutoGenerated: false },
  ]);
  assert.equal(normalized[0].firstName, "");
  assert.equal(normalized[0].lastName, "Stone");
});

test("Keeps the auto flag when a last name is provided", () => {
  const normalized = normalizeNames([
    { firstName: "Alex", lastName: "Stone", isAutoGenerated: true },
  ]);
  assert.equal(normalized[0].lastName, "Stone");
  assert.equal(normalized[0].lastNameSource, "auto");
});

test("Builds name keys even with missing fields", () => {
  const key = getNameKey({});
  assert.equal(key, "|");
});
